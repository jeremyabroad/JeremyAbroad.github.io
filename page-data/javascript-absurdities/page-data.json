{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript-absurdities/","webpackCompilationHash":"c5e926c62437d9815d94","result":{"data":{"site":{"siteMetadata":{"title":"Jeremy Abroad","author":"Jeremy Bernier"}},"markdownRemark":{"id":"1321158f-68d3-587e-9053-e5dedc5c807a","excerpt":"Javascript is a funky language. Here are some obvious design flaws:1. Regex  method is inconsistent when global flag is setToday at work I…","html":"<p>Javascript is a funky language. Here are some obvious design flaws:</p>\n<p><strong>1. <a href=\"http://stackoverflow.com/questions/1520800/why-regexp-with-global-flag-in-javascript-give-wrong-results\">Regex <code class=\"language-text\">test()</code> method is inconsistent when global flag is set</a></strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var pattern = /hi/g;\npattern.test(&#39;hi&#39;); //true\npattern.test(&#39;hi&#39;); //false</code></pre></div>\n<p>Today at work I spent hours on a witch hunt trying to pinpoint the cause of a bug that was delaying a production release. It ended up coming down to this absurd Javascript quirk within a single “if” statement inside a portion of code that hadn’t been touched in a year.</p>\n<p><strong>2. null and undefined</strong></p>\n<p>Having separate null and undefined types just adds unnecessary confusion.</p>\n<p>The best way to check whether variable is null or undefined is <code class=\"language-text\">if (varname == null)</code>. Using the triple equals (which is preferred in almost every other situation) will not catch both types.</p>\n<p><strong>3. typeof</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">typeof [] //&quot;object&quot;\ntypeof null //&quot;object&quot;\ntypeof NaN //&quot;number&quot;</code></pre></div>\n<p>Wtf?</p>\n<p><strong>4. NaN != NaN</strong></p>\n<p>To check if a value is NaN, you have to use <code class=\"language-text\">isNaN()</code>.</p>\n<p><strong>5. <code class=\"language-text\">arguments</code> inside a function is an “Array-like” Object instead of an Array</strong></p>\n<p>This is ridiculous. The convention is to use something like <code class=\"language-text\">var args = Array.prototype.slice.call(arguments)</code> to convert the “Array-like Object” into an Array (and of course that’s totally clear).</p>\n<p><strong>6. Checking deep nested objects is a hassle</strong></p>\n<p>Want to check if <code class=\"language-text\">obj.prop1.thing2.key3 === &quot;hello&quot;</code>? If obj.prop1.thing2 is not an object, then a TypeError is thrown and your code will abort. So you have to check `obj &#x26;&#x26; obj.prop1 &#x26;&#x26; obj.prop1.thing2 &#x26;&#x26; obj.prop1.thing2.key3 === “hello”. Or you can use a try/catch function or use a utility function (eg. using Lodash or writing your own).</p>\n<p><strong>7. Math.abs(null) === 0</strong></p>\n<p>null &#x3C;= 0 //true\nnull &#x3C; 0 //false\nnull == 0 //false</p>\n<p><strong>8. <a href=\"http://stackoverflow.com/questions/17106681/parseint-vs-unary-plus-when-to-use-which\">No clear sane way to parse integers</a></strong></p>\n<p>parseInt() is not guaranteed to default to base 10, so you have to explicitly pass in 10 as the base.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">parseInt(&#39;2424blahblahblah&#39;, 10) //NaN</code></pre></div>\n<p>The ”+” sign is commonly used to parse integers, but is a little different and has its own pitfalls as well. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">+&#39;&#39; === 0 //true\n+true === 1 //true\n+false === 0 //true\n\n+&#39;2e3&#39; === 2000 //true\nparseInt(&#39;2e3&#39;, 10) === 2 //true</code></pre></div>\n<p>Be careful:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[1,2,3].map(x =&gt; {hi: ‘ok’}) //[undefined, undefined, undefined]\n[1,2,3].map(x =&gt; ({hi: ‘ok’})) // [Object. Object. Object][1,2,3].map(x =&gt; {return {hi: &#39;ok’}}) // [Object. Object. Object]</code></pre></div>","frontmatter":{"title":"Javascript Absurdities","date":"December 08, 2015"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/javascript-absurdities/","previous":{"fields":{"slug":"/2d-html5-canvas-javascript-game-tips/"},"frontmatter":{"title":"Tips for developing a 2D HTML5 Canvas Javascript game","tags":["tech"]}},"next":{"fields":{"slug":"/straight_as/"},"frontmatter":{"title":"How I went from a 3.0 student to a 4.0 student","tags":null}}}}}