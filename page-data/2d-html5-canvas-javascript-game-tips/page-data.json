{"componentChunkName":"component---src-templates-blog-post-js","path":"/2d-html5-canvas-javascript-game-tips/","webpackCompilationHash":"c5e926c62437d9815d94","result":{"data":{"site":{"siteMetadata":{"title":"Jeremy Abroad","author":"Jeremy Bernier"}},"markdownRemark":{"id":"7d375623-9c79-5114-a1fd-b9a82bbcd7bd","excerpt":"I recently had the pleasure of creating a 2D HTML5 Canvas game from scratch. Here are some tips and takeaways that might save you some time…","html":"<p>I recently had the pleasure of creating a 2D HTML5 Canvas game from scratch. Here are some tips and takeaways that might save you some time if you intend to do the same.</p>\n<p><strong>1. Use <code class=\"language-text\">requestAnimationFrame()</code></strong></p>\n<p>Use this instead of <code class=\"language-text\">setTimeout</code> for your game loop. Here’s a polyfill you can use for cross-browser support:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">window.requestAnimationFrame = window.requestAnimationFrame\n    || window.webkitRequestAnimationFrame\n    || window.mozRequestAnimationFrame\n    || window.msRequestAnimationFrame\n    || function(callback) { return setTimeout(callback, 1000 / 60); };</code></pre></div>\n<p><strong>2. Make sure your game engine takes into account the varying time <code class=\"language-text\">delta</code> (because <code class=\"language-text\">requestAnimationFrame</code> does not guarantee a consistent FPS)</strong></p>\n<p>If you do not take into account the varying time <code class=\"language-text\">delta</code> between consecutive iterations of your game loop when using <code class=\"language-text\">requestAnimationFrame</code>, then your game or simulation will run differently each time. This is bad. (Also, see #5)</p>\n<p><strong>3. Use <code class=\"language-text\">performance.now()</code> for precision timing</strong></p>\n<p>Here’s a polyfill you can use in case the browser doesn’t support the performance API:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">window.performance = window.performance || {};\nwindow.performance.now = (function() {\n  return performance.now       ||\n         performance.mozNow    ||\n         performance.msNow     ||\n         performance.oNow      ||\n         performance.webkitNow ||\n         function() { return new Date().getTime(); };\n})();</code></pre></div>\n<p><strong>4. When using <code class=\"language-text\">ctx.fillRect(x, y, width, height)</code>, make sure that <code class=\"language-text\">x</code> and <code class=\"language-text\">y</code> are integers to avoid blurriness</strong></p>\n<p><code class=\"language-text\">fillRect(x, y, width, height)</code> renders a rectangle on the Canvas. The problem is that when <code class=\"language-text\">x</code> or <code class=\"language-text\">y</code> is not an integer, the rectangle is going to look blurry.</p>\n<p>The solution? Ensure that <code class=\"language-text\">x</code> and <code class=\"language-text\">y</code> are always integers by rounding. </p>\n<p>If you’re not afraid of modifying native prototypes, here’s a function you can define that could be used instead of <code class=\"language-text\">fillRect()</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CanvasRenderingContext2D.prototype.fillRectClean = function (x, y, width, height) {\n  this.fillRect(Math.round(x), Math.round(y), width, height);\n};</code></pre></div>\n<p><strong>5. Don’t attempt to build your own physics engine from scratch if you intend on actually finishing your game</strong></p>\n<p>Do not underestimate the amount of work involved in building a physics engine. Basic tile-based collision isn’t a big deal (eg. 2D Pokemon game), but anything more complex (eg. Angry Birds) is going to take a lot more work than you probably think it will. </p>\n<p>Detecting whether rectangles and circles are intersecting is easy. But what if the two objects are moving so fast that they go through each other and never technically intersect (solution: continuous collision detection or limiting velocities)? What if you have a million objects and performance is taking a severe hit (ever heard of a QuadTree)? Detecting collisions is one thing, but the resolution itself is even harder and requires a good understanding of physics (do the terms impulse resolution and collision normal mean anything to you?). Oh and what if you want to add rotation into the mix? What about more complex shapes like polygons, both concave and convex?</p>\n<p>If you’re smart and willing to dive deep into physics and computer science, then sure you’ll be able to figure it out because these are solved problems with resources out there to help you learn. But if your goal is to make a game, then you’ll save yourself a whole lot of time and headache by not reinventing the wheel and just using an existing battle-tested physics engine. </p>\n<p>If you’re not convinced, take a look at the source code of <a href=\"https://github.com/liabru/matter-js\">Matter.js</a> to get an idea of what’s involved. And keep in mind that Matter.js is still in alpha status and has bugs (eg. in the “Mixed Shapes” demo you can sling objects through the walls).</p>\n<p><strong>6. You should probably just use Unity</strong></p>\n<p>I hate to say it, but you’re probably just better off using Unity. Making a game is an extremely daunting task, and Unity simplifies things tremendously, allowing you to focus exclusively on the content of the game without being bogged down by extraneous things (eg. game engine design, physics, making a level editor, handling sprites, sound, etc.). And Unity enables you to export to any platform (iOS, Android, Oculus, consoles, etc).</p>\n<p>If you really want to stick with HTML5/Javascript, you’d save a ton of time by using a framework like <a href=\"https://phaser.io\">Phaser</a>. </p>\n<hr>\n<p>As someone who prefers Open Source and enjoys the process of building the game engine more than building the actual game itself, it pains me to say “just use Unity”. But for the majority of games out there that don’t require anything too crazy, using an established game engine like Unity or Unreal is probably your best bet. </p>\n<p>But by all means build your own game engine from scratch for the sake of intellectual curiosity. Just realize that you’re probably reinventing the wheel.</p>","frontmatter":{"title":"Tips for developing a 2D HTML5 Canvas Javascript game","date":"October 01, 2015"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2d-html5-canvas-javascript-game-tips/","previous":{"fields":{"slug":"/weekend-in-soul-and-tokyo/"},"frontmatter":{"title":"A Weekend in Seoul and Tokyo","tags":["travel"]}},"next":{"fields":{"slug":"/javascript-absurdities/"},"frontmatter":{"title":"Javascript Absurdities","tags":["tech"]}}}}}